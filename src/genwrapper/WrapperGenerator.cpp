#include "WrapperGenerator.h"
#include "PathNameUtils.h"
#include "TypeNameUtils.h"
#include "FileSystemUtils.h"
#include "Notify.h"

#include <boost/regex.hpp>

#include <fstream>
#include <sstream>
#include <iostream>

namespace
{

    bool begins_with(const std::string &s1, const std::string &s2)
    {
        return s1.length() >= s2.length() && (s1.substr(0, s2.length()) == s2);
    }

    template<typename Iter>
    bool write_lines(const std::string &filename, Iter beg, Iter end)
    {
        std::ofstream ofs(filename.c_str());
        if (!ofs.is_open()) 
            return false;

        for (Iter i=beg; i!=end; ++i)
            if (!(ofs << *i << "\n"))
                return false;

        return true;
    }

}

WrapperGenerator::WrapperGenerator(const TypeRegistry &reg, const std::string &out_dir, const std::string &dst_dir, const std::string &app_dir, bool create_lists, const Configuration &cfg)
:    reg_(reg),
    dst_dir_(PathNameUtils::consolidateDelimiters(out_dir, true) + PathNameUtils::consolidateDelimiters(dst_dir, true)),
    app_dir_(PathNameUtils::consolidateDelimiters(app_dir, true)),
    cfg_(cfg),
    create_lists_(create_lists)
{
}

void WrapperGenerator::generate()
{
    stats_ = Statistics();

    FileMap file_map;
    FileMap created_files;
    FileMap modified_files;

    for (TypeRegistry::const_iterator i=reg_.begin(); i!=reg_.end(); ++i)
    {
        std::string filename = dst_dir_ + PathNameUtils::replaceExtension(i->first, "cpp");

        if (cfg_.isFileSuppressed(i->first))
        {
            Notify::info("suppressing output file `" + filename + "' on user request");
            continue;
        }

        std::ostringstream output;

        file_map[PathNameUtils::getDirectoryName(i->first, false)].push_back(PathNameUtils::getRelativePathAfter(filename, "/"));

        std::set<std::string> incls;
        incls.insert(i->first);
        
        for (TypeRegistry::TypeList::const_iterator j=i->second.begin(); j!=i->second.end(); ++j)
            std::copy(j->needed_headers.begin(), j->needed_headers.end(), std::inserter(incls, incls.end()));
        
        write_header(incls, output);

        // get custom options
        const FileOptions *fo = cfg_.getFileOptions(i->first);

        // replace content if requested
        if (fo && fo->entirely_replaced)
        {
            Notify::info("replacing content of file `" + filename + "' on user request");
            output << fo->replace_text << "\n";
            continue;
        }

        // write user-defined header
        
        if (fo) write_user_header(*fo, output);

        for (TypeRegistry::TypeList::const_iterator j=i->second.begin(); j!=i->second.end(); ++j)
        {
            if (cfg_.isReflectorSuppressed(j->type_name))
            {
                Notify::info("suppressing reflector for type `" + j->type_name + "' on user request");
                continue;
            }
            write_reflector(*j, output);
        }

        // write user-defined footer
        if (fo) write_user_footer(*fo, output);

        int c = compare_text_files(filename, output.str());
        if (c == 0)
        {
            Notify::info("no changes in file `" + filename + "'");
        }
        else
        {
            std::ofstream ofs;
            Notify::info("creating file `" + filename + "'");        
            if (!FileSystemUtils::createFile(filename, ofs))
            {
                Notify::warn("could not create file `" + filename + "'");
            }
            else
            {
                if (c == -2)
                    created_files[PathNameUtils::getDirectoryName(i->first, false)].push_back(PathNameUtils::getRelativePathAfter(filename, "/"));
                else
                    modified_files[PathNameUtils::getDirectoryName(i->first, false)].push_back(PathNameUtils::getRelativePathAfter(filename, "/"));
                ofs << output.str();
            }
        }
    }

    if (!file_map.empty())
    {
        if (create_lists_)
        {
            Notify::notice("creating lists of added/removed files");
            create_lists(file_map, created_files, modified_files);
        }
    }
}

void WrapperGenerator::write_header(const std::set<std::string> &incls, std::ostream &os) const
{
    os << "// " << std::string(75, '*') << "\n";
    os << "//\n";
    os << "//   Generated automatically by genwrapper.\n";
    os << "//   Please DO NOT EDIT this file!\n";
    os << "//\n";
    os << "// " << std::string(75, '*') << "\n\n";

    os << "#include <osgIntrospection/ReflectionMacros>\n";
    os << "#include <osgIntrospection/TypedMethodInfo>\n";
    os << "#include <osgIntrospection/StaticMethodInfo>\n";
    os << "#include <osgIntrospection/Attributes>\n";
    os << "\n";
    for (std::set<std::string>::const_iterator i=incls.begin(); i!=incls.end(); ++i)
        os << "#include <" << *i << ">\n";
    os << "\n";
    os << "// Must undefine IN and OUT macros defined in Windows headers\n";
    os << "#ifdef IN\n";
    os << "#undef IN\n";
    os << "#endif\n";
    os << "#ifdef OUT\n";
    os << "#undef OUT\n";
    os << "#endif\n";
    os << "\n";
}

void WrapperGenerator::write_public_attribut(const AttributDesc &ad, const TypeDesc &td, std::ostream &os) 
{
        os << "\tI_PublicMemberProperty";
        os << "(" << replace_commas(ad.type) << ", " << ad.name << ");\n";

        ++stats_.num_public_properties;
        ++stats_.total_properties;
}

void WrapperGenerator::write_property(const PropertyDesc &pd, const TypeDesc &td, std::ostream &os) 
{
    const PropertyOptions *opt = cfg_.getPropertyOptions(td.type_name, pd.name);

    if (opt && opt->entirely_replaced)
    {
        Notify::info("replacing definition of property `" + pd.name + "' in type `" + td.type_name + "' on user request");
        ++stats_.total_properties;
        os << opt->replace_text << "\n";
        return;
    }

    if (pd.type == PropertyDesc::SIMPLE)
    {
        os << "\tI_SimpleProperty(" << replace_commas(pd.type_name) << ", " << pd.name << ", \n\t";
        os <<   "                 " << ((!pd.get_method.empty())    ? pd.get_method    : "0") << ", \n\t";
        os <<   "                 " << ((!pd.set_method.empty())    ? pd.set_method    : "0") << ");\n";

        ++stats_.num_simple_properties;
    }
    else if (pd.type == PropertyDesc::ARRAY)
    {
        os << "\tI_ArrayProperty(" << replace_commas(pd.type_name) << ", " << pd.name << ", \n\t";
        os <<   "                " << ((!pd.get_method.empty())    ? pd.get_method    : "0") << ", \n\t";
        os <<   "                " << ((!pd.set_method.empty())    ? pd.set_method    : "0") << ", \n\t";        
        os <<   "                " << ((!pd.count_method.empty())  ? pd.count_method  : "0") << ", \n\t";
        os <<   "                " << ((!pd.add_method.empty())    ? pd.add_method    : "0") << ", \n\t";
        os <<   "                " << ((!pd.insert_method.empty()) ? pd.insert_method : "0") << ", \n\t";
        os <<   "                " << ((!pd.remove_method.empty()) ? pd.remove_method : "0") << ");\n";

        ++stats_.num_array_properties;
    }
    else if (pd.type == PropertyDesc::INDEXED)
    {
        os << "\tI_IndexedProperty(" << replace_commas(pd.type_name) << ", " << pd.name << ", \n\t";
        os <<   "                  " << ((!pd.get_method.empty())    ? pd.get_method    : "0") << ", \n\t";
        os <<   "                  " << ((!pd.set_method.empty())    ? pd.set_method    : "0") << ", \n\t";        
        os <<   "                  " << ((!pd.remove_method.empty()) ? pd.remove_method : "0") << ");\n";

        ++stats_.num_indexed_properties;
    }            
    ++stats_.total_properties;
    
//  David Callu 2006/10/04
//  There are any "Attribute" Macro in ReflectionMacros
//     if (opt)
//     {
//         for (StringList::const_iterator i=opt->attributes.begin(); i!=opt->attributes.end(); ++i)
//             os << "\t\tAttribute(" << *i << ");\t// user-defined\n";
//     }
}

void WrapperGenerator::write_method(const FunctionDesc &fd, const TypeDesc &td, bool is_protected, std::ostream &os) 
{
    const MethodOptions *opt = cfg_.getMethodOptions(td.type_name, fd.name_signature);

    if (opt && opt->entirely_replaced)
    {
        Notify::info("replacing definition of method `" + fd.name_signature + "' in type `" + td.type_name + "' on user request");
        ++stats_.total_methods;
        os << opt->replace_text << "\n";
        return;
    }
    
    if (fd.is_destructor())
    {
        Notify::debug("skipping method `" + fd.name + "' because it is a destructor");
        return;
    }

    if (fd.name.substr(0, 8) == "operator")
    {
        Notify::debug("skipping method `" + fd.name + "' because it is an operator");
        return;
    }

    std::string prefix;
    if (fd.is_static)
        prefix = "Static";

    bool has_defaults = TypeNameUtils::hasDefaults(fd.params);

    std::size_t macroNameSize = os.tellp();
    
    os << "\tI_";
    if (is_protected)
    {
        os << "Protected";
        ++stats_.total_protected;
    }
    if (fd.is_static)
    {
        os << "Static";
        ++stats_.total_static;
    }

    if (fd.is_constructor(td))
    {
        os << "Constructor";
        ++stats_.total_constructors;
    }
    else
        os << "Method";
    if (has_defaults)
        os << "WithDefaults";
    os << static_cast<int>(fd.params.size());

    os << "(";
    
    macroNameSize = (std::size_t) os.tellp() - macroNameSize;
    
    if (!fd.is_constructor(td))
        os << fd.return_type_specifier << ", " << fd.name;
    for (ParameterList::const_iterator j=fd.params.begin(); j!=fd.params.end(); ++j)
    {
        if (j!=fd.params.begin() || !fd.is_constructor(td))
            os << ", ";
        os << "IN, ";
        os << replace_commas(j->type_specifier) << ", ";
        os << replace_commas(j->name);
        if (has_defaults)
            os << ", " << j->default_value;
    }
    if (!fd.is_constructor(td) || (fd.is_constructor(td) && !fd.params.empty()))
    {
        os << ",\n\t"; 
        os.width(macroNameSize - 1);
        os << " ";
    }

    if (fd.is_constructor(td) && fd.params.size() == 1)
    {
        os << "Properties::" << (fd.is_explicit ? "EXPLICIT" : "NON_EXPLICIT")
           << ",\n\t"; os.width(macroNameSize - 1); os << " ";
    }
    if (!fd.is_constructor(td) && !fd.is_static)
    {
        os << "Properties::" << (fd.is_pure_virtual ? "PURE_VIRTUAL" : fd.is_virtual ? "VIRTUAL" : "NON_VIRTUAL")
           << ",\n\t"; os.width(macroNameSize - 1); os << " ";

        if (is_protected)
        {
            // it's not possible to pass a pointer to a protected
            // function, from which the const-ness can be derived, so we
            // must specify that state explicitly
            os << "Properties::" << (fd.is_const ? "CONST" : "NON_CONST")
               << ",\n\t"; os.width(macroNameSize - 1); os << " ";
        }
    }
    os << fd.name_signature << ",\n\t"; os.width(macroNameSize); 
    os << "\"" << fd.briefHelp << "\",\n\t"; os.width(macroNameSize);
    os << "\"" << fd.detailedHelp << "\");\n";
        
    ++stats_.total_methods;
}

void WrapperGenerator::write_reflector(const TypeDesc &td, std::ostream &os) 
{
    if (td.is_namespace) return;

    ++stats_.total_reflectors;

    const ReflectorOptions *opt = cfg_.getReflectorOptions(td.type_name);
    if (opt && opt->entirely_replaced)
    {
        Notify::info("replacing content of reflector `" + td.type_name + "' on user request");
        os << opt->replace_text << "\n";
        ++stats_.num_custom;
        return;
    }

    if (td.undefined)
    {
        handle_undefined_type(td, os);
        return;
    }

    if (!td.alias.empty())
    {
        os << "TYPE_NAME_ALIAS(" << replace_commas(td.alias) << ", " << replace_commas(td.type_name) << ")\n\n";
        ++stats_.num_typedefs;
        return;
    }

    ReflectorOptions::TypeKind kind = ReflectorOptions::VALUE_TYPE;
    if (opt && opt->type_kind != ReflectorOptions::DEFAULT_TYPE)
        kind = opt->type_kind;
    else
    {
        if (!td.base_types.empty()) kind = ReflectorOptions::OBJECT_TYPE;   // probably it's an object type
        if (td.destructor_private) kind = ReflectorOptions::OBJECT_TYPE;    // can't be value type
        if (td.is_abstract) kind = ReflectorOptions::ABSTRACT_OBJECT_TYPE;  // can't be value type
        if (!td.enum_labels.empty()) kind = ReflectorOptions::ENUM_TYPE;
    }
    
    bool has_auto_constructor = false;

    std::string refmacro;
    if (kind == ReflectorOptions::ENUM_TYPE)
    {
        refmacro = "BEGIN_ENUM_REFLECTOR";
        has_auto_constructor = true;
        ++stats_.num_enums;
        ++stats_.num_value_types;
    }
    else
    {
        if (kind == ReflectorOptions::ABSTRACT_OBJECT_TYPE)
        {
            refmacro = "BEGIN_ABSTRACT_OBJECT_REFLECTOR";
            ++stats_.num_abstract_object_types;
            ++stats_.num_object_types;
        }
        if (kind == ReflectorOptions::OBJECT_TYPE)
        {
            refmacro = "BEGIN_OBJECT_REFLECTOR";
            ++stats_.num_object_types;
        }
        if (kind == ReflectorOptions::VALUE_TYPE)
        {
            refmacro = "BEGIN_VALUE_REFLECTOR";
            ++stats_.num_value_types;
        }
    }

    os << refmacro << "(" << replace_commas(td.type_name) << ")\n";

    // write attributes
    if (opt)
    {
        for (StringList::const_iterator i=opt->attributes.begin(); i!=opt->attributes.end(); ++i)
            os << "\t\tAttribute(" << *i << ");\t// user-defined\n";
    }

    // write custom header
    if (opt) write_user_header(*opt, os);

    // write custom readerwriter
    if (opt && opt->readerwriter_specified)
    {
        Notify::info("adding user-defined ReaderWriter for type `" + td.type_name + "'");
        os << "\tI_ReaderWriter(" << opt->readerwriter << ");\t// user-defined\n";
    }

    // write custom comparator
    if (opt && opt->comparator_specified)
    {
        Notify::info("adding user-defined Comparator for type `" + td.type_name + "'");
        os << "\tI_Comparator(" << opt->comparator << ");\t// user-defined\n";
    }

    if (!td.declaring_file_name.empty())
    {
        os << "\tI_DeclaringFile(\"" << td.declaring_file_name << "\");\n";
    }

    for (BaseTypeList::const_iterator i=td.base_types.begin(); i!=td.base_types.end(); ++i)
    {
        os << "\tI_";
        if (i->is_virtual) os << "Virtual";
        os << "BaseType(" << replace_commas(i->name) << ");\n";
    }

    for (StringList::const_iterator i=td.enum_labels.begin(); i!=td.enum_labels.end(); ++i)
    {
        os << "\tI_EnumLabel(" << replace_commas(*i) << ");\n";
    }

    if (!td.default_constructor_private && !td.has_custom_constructors && !has_auto_constructor)
    {
        // add default constructor
        FunctionDesc fd;
        fd.name = TypeNameUtils::getUnqualifiedIdentifier(td.type_name);
        fd.gen_name_signature();
        write_method(fd, td, false, os);
    }

    for (FunctionList::const_iterator i=td.methods.begin(); i!=td.methods.end(); ++i)
    {
        write_method(*i, td, false, os);
    }

    for (FunctionList::const_iterator i=td.prot_methods.begin(); i!=td.prot_methods.end(); ++i)
    {
        write_method(*i, td, true, os);
    }

    for (PropertyList::const_iterator i=td.properties.begin(); i!=td.properties.end(); ++i)
    {
        write_property(*i, td, os);
    }

    for (AttributList::const_iterator i=td.public_attrib.begin(); i!=td.public_attrib.end(); ++i)
    {
        write_public_attribut(*i, td, os);
    }

    // write custom footer
    if (opt) write_user_footer(*opt, os);

    os << "END_REFLECTOR\n\n";
}

void WrapperGenerator::handle_undefined_type(const TypeDesc &td, std::ostream &os) 
{
    ++stats_.num_stdcontainers;

    if (begins_with(td.type_name, "std::vector") ||
        begins_with(td.type_name, "std::deque"))
    {
        os << "STD_VECTOR_REFLECTOR(" << replace_commas(td.type_name) << ")\n\n";        
        return;
    }

    if (begins_with(td.type_name, "std::set") ||
        begins_with(td.type_name, "std::multiset"))
    {
        os << "STD_SET_REFLECTOR(" << replace_commas(td.type_name) << ")\n\n";
        return;
    }

    if (begins_with(td.type_name, "std::list"))
    {
        os << "STD_LIST_REFLECTOR(" << replace_commas(td.type_name) << ")\n\n";
        return;
    }

    if (begins_with(td.type_name, "std::map") ||
        begins_with(td.type_name, "std::multimap"))
    {
        os << "STD_MAP_REFLECTOR(" << replace_commas(td.type_name) << ")\n\n";
        return;
    }

    if (begins_with(td.type_name, "std::pair"))
    {
        os << "STD_PAIR_REFLECTOR(" << replace_commas(td.type_name) << ")\n\n";
        return;
    }

    --stats_.num_stdcontainers;
    Notify::warn("could not write a reflector for undefined type `" + td.type_name + "'");
}

std::string WrapperGenerator::replace_commas(const std::string &s) const
{
    std::ostringstream oss;
    for (std::string::const_iterator i=s.begin(); i!=s.end(); ++i)
    {
        if (*i == ',')
            oss << " COMMA ";
        else
            oss << *i;
    }
    return oss.str();
}

void WrapperGenerator::write_user_header(const OptionBase &opt, std::ostream &os)
{
    if (!opt.header_text.empty())
        os << opt.header_text << "\n";
}

void WrapperGenerator::write_user_footer(const OptionBase &opt, std::ostream &os)
{
    if (!opt.footer_text.empty())
        os << opt.footer_text << "\n";
}

bool WrapperGenerator::read_text_file(const std::string &filename, std::string &text) const
{
    std::ifstream ifs(filename.c_str());
    if (!ifs.is_open())
    {
        ifs.clear();
        ifs.open((app_dir_ + filename).c_str());
        if (!ifs.is_open())
            return false;
    }

    std::string line;
    while (std::getline(ifs, line))
    {
        text.append(line);
        text.push_back('\n');
    }

    return true;
}

int WrapperGenerator::compare_text_files(const std::string &filename, const std::string &content) const
{
    std::ifstream ifs(filename.c_str());
    if (!ifs.is_open()) 
        return -2;

    std::string text;
    std::string line;
    while (std::getline(ifs, line))
    {
        text.append(line);
        text.push_back('\n');
    }

    return TypeNameUtils::trim(text).compare(TypeNameUtils::trim(content));
}

void WrapperGenerator::create_lists(const FileMap &file_map, const FileMap &created_files, const FileMap &modified_files)
{
    for (FileMap::const_iterator i=file_map.begin(); i!=file_map.end(); ++i)
    {
        std::vector<std::string> added, modified;

        FileMap::const_iterator nf;

        nf = created_files.find(i->first);
        if (nf != created_files.end())
            added.assign(nf->second.begin(), nf->second.end());

        nf = modified_files.find(i->first);
        if (nf != modified_files.end())
            modified.assign(nf->second.begin(), nf->second.end());

        std::set<std::string> existing;
        FileSystemUtils::findSourceFilesInDirectory(dst_dir_ + i->first, existing);
        for (std::vector<std::string>::const_iterator j=i->second.begin(); j!=i->second.end(); ++j)
        {
            std::set<std::string>::iterator ex = existing.find(*j);
            if (ex != existing.end())
                existing.erase(ex);
        }

        write_lines(dst_dir_ + i->first + "/removed.gw", existing.begin(), existing.end());
        write_lines(dst_dir_ + i->first + "/added.gw", added.begin(), added.end());
        write_lines(dst_dir_ + i->first + "/modified.gw", modified.begin(), modified.end());
    }    
}
